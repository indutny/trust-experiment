#!/usr/bin/env node
'use strict';

const fs = require('fs');

const MAX_DEPTH = 8;
const MAXIMIZE = 10000;
const PER_AUTHOR = 10000;

const Graph = require('../');

const file = fs.readFileSync(process.argv[2]);
const buf = new Uint32Array(file.length >>> 2);
for (let i = 0; i < buf.length; i++)
  buf[i] = file.readUInt32LE(i * 4);

const users = [];
{
  const seen = new Set();
  for (let i = 0; i < buf.length; i++) {
    if (seen.has(buf[i]))
      continue;

    seen.add(buf[i]);
    users.push(buf[i]);
  }
}

function shuffle(buf) {
  const n = buf.length >>> 1;
  for (var i = 0; i < n - 1; i++) {
    const j = Math.floor(i + Math.random() * (n - i));

    const t0 = buf[i * 2];
    const t1 = buf[i * 2 + 1];
    buf[i * 2] = buf[j * 2];
    buf[i * 2 + 1] = buf[j * 2 + 1];
    buf[j * 2] = t0;
    buf[j * 2 + 1] = t1;
  }
}

function test(to) {
  shuffle(buf);

  const g = new Graph(to, {
    maxDepth: MAX_DEPTH,
    maximize: MAXIMIZE
  });

  for (var i = 0; i < buf.length; i += 2)
    g.link(buf[i + 1], buf[i]);

  for (var i = 0; i < PER_AUTHOR; i++) {
    const from = users[(Math.random() * users.length) | 0];
    if (from === to)
      continue;

    const route = g.build(from);
    const length = route ? route.length : 0;
    buckets[length]++;
  }
}

const buckets = new Array(MAX_DEPTH + 1).fill(0);

for (;;) {
  const to = users[(Math.random() * users.length) | 0];

  const route = test(to);
  console.log(buckets.join(', '));
}
